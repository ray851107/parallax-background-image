{
  "version": 3,
  "sources": ["../src/config.js", "../src/parallax-viewport.js", "../src/transform.js", "../src/parallax-element.js", "../src/main.js"],
  "sourcesContent": ["export const USE_3D = isChrome();\r\n\r\nfunction isChrome() {\r\n  const userAgent = navigator.userAgent;\r\n  return (\r\n    userAgent.indexOf(\"Chrome/\") !== -1 && userAgent.indexOf(\"Edge/\") === -1\r\n  );\r\n}\r\n", "import { USE_3D } from \"./config.js\";\n\nconst template = document.createElement(\"template\");\ntemplate.innerHTML = `\n  <style>\n    :host {\n      display: block;\n      overflow-x: hidden;\n      overflow-y: scroll;\n      -webkit-overflow-scrolling: touch;\n      ${USE_3D ? \"perspective: 1px;\" : \"\"}\n      ${USE_3D ? \"perspective-origin: center center;\" : \"\"}\n    }\n    :host([hidden]) {\n      display: none;\n    }\n  </style>\n  <slot></slot>\n`;\n\nexport class ParallaxViewport extends HTMLElement {\n  constructor() {\n    super();\n\n    this.attachShadow({ mode: \"open\" });\n    this.shadowRoot.appendChild(template.content.cloneNode(true));\n  }\n}\n", "import { USE_3D } from \"./config.js\";\n\nexport function transform_(bg, element, viewport, options) {\n  coverElement_(bg, element, viewport, options);\n  alignX_(bg, element, viewport, options);\n  if (USE_3D) {\n    parallax3d_(bg, element, viewport, options);\n  } else {\n    parallax2d_(bg, element, viewport, options);\n  }\n}\n\nfunction scale_(bg, s) {\n  bg.x *= s;\n  bg.y *= s;\n  bg.z *= s;\n  bg.w *= s;\n  bg.h *= s;\n}\n\nfunction coverElement_(bg, element, viewport, options) {\n  const minWidth = element.w;\n  const minHeight = viewport.h + options.velocity * (viewport.h - element.h);\n  const widthScale = minWidth / bg.w;\n  const heightScale = minHeight / bg.h;\n  scale_(bg, Math.max(widthScale, heightScale));\n}\n\nfunction alignX_(bg, element, viewport, options) {\n  bg.x = (0.5 - options.alignX) * (bg.w - element.w);\n}\n\nfunction parallax3d_(bg, element, viewport, options) {\n  const velocity = options.velocity;\n  scale_(bg, 1 / velocity);\n  bg.z += 1 - 1 / velocity;\n  bg.x -= element.x * (1 - 1 / velocity);\n}\n\nfunction parallax2d_(bg, element, viewport, options) {\n  bg.y += element.y * (options.velocity - 1);\n}\n", "import { USE_3D } from \"./config.js\";\nimport { transform_ } from \"./transform.js\";\n\nconst template = document.createElement(\"template\");\ntemplate.innerHTML = `\n  <style>\n    :host {\n      display: block;\n      position: relative;\n      overflow: hidden;\n      background: none !important;\n      background-image: none !important;\n    }\n    :host([hidden]) {\n      display: none;\n    }\n    #image {\n      position: absolute;\n      left: 50%;\n      top: 50%;\n      transform-origin: center center 0;\n      will-change: transform;\n      pointer-events: none;\n    }\n    ::slotted(*) {\n      position: relative;\n    }\n  </style>\n  <img id=\"image\">\n  <slot></slot>\n`;\n\nexport class ParallaxElement extends HTMLElement {\n  static get observedAttributes() {\n    return [\"image-src\"];\n  }\n\n  get velocity() {\n    return parseFloat(this.getAttribute(\"velocity\") ?? \"0.8\");\n  }\n  set velocity(value) {\n    this.setAttribute(\"velocity\", value.toString());\n  }\n  get alignX() {\n    const str = this.getAttribute(\"align-x\");\n    if (str === \"left\") return 0;\n    if (str === \"center\") return 0.5;\n    if (str === \"right\") return 1;\n    const num = parseFloat(str);\n    if (isFinite(num)) return num / 100;\n    return 0.5;\n  }\n  set alignX(value) {\n    this.setAttribute(\"align-x\", `${value * 100}%`);\n  }\n  get imageSrc() {\n    return this.getAttribute(\"image-src\");\n  }\n  set imageSrc(value) {\n    this.setAttribute(\"image-src\", value);\n  }\n\n  constructor() {\n    super();\n\n    this.attachShadow({ mode: \"open\" });\n    this.shadowRoot.appendChild(template.content.cloneNode(true));\n    this.image = this.shadowRoot.getElementById(\"image\");\n    this.image.addEventListener(\"load\", this.updateRect);\n    this.image.src = this.imageSrc;\n    this.bgRect = { x: 0, y: 0, z: 0, w: 0, h: 0 };\n    this.dirty = true;\n\n    window.addEventListener(\"resize\", this.updateRect);\n\n    const renderLoop = () => {\n      this.render();\n      window.requestAnimationFrame(renderLoop);\n    };\n    window.requestAnimationFrame(renderLoop);\n  }\n\n  connectedCallback() {\n    this.viewport = this.closest(\"parallax-viewport\");\n    if (!USE_3D) {\n      this.viewport?.addEventListener(\"scroll\", this.updateRect);\n    }\n  }\n\n  disconnectedCallback() {\n    if (!USE_3D) {\n      this.viewport?.removeEventListener(\"scroll\", this.updateRect);\n    }\n    this.viewport = null;\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (name === \"image-src\") {\n      this.image.src = this.imageSrc;\n    }\n  }\n\n  updateRect = () => {\n    if (this.viewport == null) return;\n\n    const viewportRect = getRect(this.viewport);\n    const elementRect = getRect(this);\n\n    elementRect.x -= viewportRect.x;\n    elementRect.y -= viewportRect.y;\n\n    const bgRect = {\n      x: 0,\n      y: 0,\n      z: 0,\n      w: this.image.naturalWidth,\n      h: this.image.naturalHeight\n    };\n    const options = {\n      velocity: this.velocity,\n      alignX: this.alignX\n    };\n    transform_(bgRect, elementRect, viewportRect, options);\n    if (this.bgRect == null || !equals(this.bgRect, bgRect)) {\n      this.dirty = true;\n    }\n    this.bgRect = bgRect;\n  };\n\n  render() {\n    if (!this.dirty) return;\n    this.dirty = false;\n    this.image.style.transform = `\n      translateX(${this.bgRect.x - this.image.naturalWidth / 2}px)\n      translateY(${this.bgRect.y - this.image.naturalHeight / 2}px)\n      translateZ(${this.bgRect.z}px)\n      scale(${this.bgRect.w / this.image.naturalWidth}, ${this.bgRect.h /\n      this.image.naturalHeight})\n    `;\n  }\n}\n\nfunction equals(a, b) {\n  return (\n    a.x === b.x && a.y === b.y && a.z === b.z && a.w === b.w && a.h === b.h\n  );\n}\n\nfunction getRect(element) {\n  const rect = element.getBoundingClientRect();\n  return {\n    x: (rect.left + rect.right) / 2,\n    y: (rect.top + rect.bottom) / 2,\n    w: rect.right - rect.left,\n    h: rect.bottom - rect.top\n  };\n}\n", "import { ParallaxViewport } from \"./parallax-viewport.js\";\nimport { ParallaxElement } from \"./parallax-element.js\";\n\ncustomElements.define(\"parallax-viewport\", ParallaxViewport);\ncustomElements.define(\"parallax-element\", ParallaxElement);\n"],
  "mappings": "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",
  "names": []
}
